/*
    PIO State Machine helpers.

    Copyright 2025 AESilky (SilkyDESIGN)
    SPDX-License-Identifier: MIT

*/
#ifndef PIOSM_H_
#define PIOSM_H_
#ifdef __cplusplus
extern "C" {
#endif

#include "stdint.h"
#include "hardware/pio.h"

/**
 * @brief Structure containing the PIO SM program offset and configuration.
 *
 * This helps with restarting a State Machine and de-initializing a State
 * Machine, as both of these operations need both the configuration and
 * the program offset.
 *
 * @param pio PIO instance
 * @param sm uint State Machine
 * @param offset uint Program offset
 * @param sm_cfg pio_sm_config Configuration of the State Machine
 */
typedef struct {
    PIO pio;                // The PIO
    uint sm;                // The State Machine
    uint offset;            // PIO program offset
    pio_sm_config sm_cfg;   // The configuration for the State Machine
} pio_sm_pocfg;

/**
 * @brief Function type definition for a PIO State-Machine default configuration
 *      method.
 * @ingroup pio_sm
 *
 * This type definition matches the function generated by the PIO assembler.
 */
typedef pio_sm_config(*piosmcfg_fn)(uint offset);

/**
 * @brief Completely configures a PIO State Machine from parameters.
 * @ingroup pio_sm
 *
 * This takes parameters that completely configure a PIO state machine. This will
 * load the program and configure the state machine.
 *
 * For the situation where more than one State Machine is using the same program
 * this can be used to load the program and configure the first State Machine,
 * then a separate function can configure the additional State Machines using
 * the program offset in the `pio_sm_pocfg` returned from this method.
 *
 * @param pio The PIO instance to use
 * @param sm The State Machine number to use
 * @param pio_prgm Pointer to the PIO program
 * @param smdefcfgfn Function that returns the default State Machine configuration
 * @param clkdiv The clock divider
 * @param join_type The FIFO join type to apply
 * @param in_bits The number of ISR bits to use (can be 0)
 * @param in_right True if the input shift is to the right (ignored if in_bits is 0)
 * @param in_auto True for Auto-Push (ignored if in_bits is 0)
 * @param out_bits The number of OSR bits to use (can be 0)
 * @param out_right True if the output shift is to the right (ignored if out_bits is 0)
 * @param out_auto True for Auto-Pull (ignored if out-bits is 0)
 * @param pin_i The first pin for IN
 * @param pin_i_cnt The number of pins for IN
 * @param pin_o The first pin for OUT
 * @param pin_o_cnt The number of pins for OUT
 * @param pin_s The first pin for SET
 * @param pin_s_cnt The number of pins for SET
 * @param pin_ss The first pin for SIDE-SET
 * @param pin_ss_cnt The number of pins for SIDE-SET
 * @param pin_jmp The pin to use for JMP. Use -1 to indicate no JMP pin.
 * @return pio_sm_pocfg Structure containing the 'pio', 'sm', 'offset', and 'sm cfg'. The offset is negative if there was an error.
 */
extern pio_sm_pocfg pio_sm_configure(PIO pio, uint sm, const pio_program_t* pio_prgm, piosmcfg_fn smdefcfgfn, float clkdiv, enum pio_fifo_join join_type, uint in_bits, bool in_right, bool in_auto, uint out_bits, bool out_right, bool out_auto, uint pin_i, int pin_i_cnt, uint pin_o, int pin_o_cnt, uint pin_s, int pin_s_cnt, uint pin_ss, int pin_ss_cnt, int pin_jmp);

/**
 * @brief Get the PIO State Machine PC value.
 *
 * This is the PC adjusted for the program load offset.
 *
 * @param smpocfg The pio_sm_pocfg containing the PIO, SM, and offset
 * @return uint8_t The PC value (adjusted for the program offset)
 */
static inline uint8_t piosm_pc(pio_sm_pocfg smpocfg) {
    return (pio_sm_get_pc(smpocfg.pio, smpocfg.sm) - smpocfg.offset);
}


/**
 * @brief Get the enabled (running) state of a PIO State Machine.
 *
 * @param pio The PIO block
 * @param sm The State Machine in the block
 * @return true The SM is enabled
 * @return false The SM is disabled
 */
static inline bool piosm_enabled(PIO pio, uint sm) {
    return ((pio->ctrl & (1u << sm)) != 0);
}

/**
 * @brief Get the enabled (running) state of a PIO State Machine.
 *
 * @param smpocfg The PIO-SM Pgm-offset and Config
 * @return true The SM is enabled
 * @return false The SM is disabled
 */
static inline bool piosm_enabled2(pio_sm_pocfg smpocfg) {
    return (piosm_enabled(smpocfg.pio, smpocfg.sm));
}

/**
 * @brief Reset a PIO State Machine, including putting the PC at the start.
 *
 * This clears (most of) the status registers, the ISR and OSR, and sets the
 * PC back to the beginning of the program.
 * This leaves the State Machine disabled.
 *
 * @param pio The PIO block
 * @param sm  The State Machine in the block
 * @param smcfg The pio_sm_pocfg containing the program offset and configuration
 */
static inline void piosm_reset(pio_sm_pocfg smpocfg) {
    pio_sm_init(smpocfg.pio, smpocfg.sm, smpocfg.offset, &smpocfg.sm_cfg);
    pio_sm_clear_fifos(smpocfg.pio, smpocfg.sm);
}

#ifdef __cplusplus
}
#endif
#endif // PIOSM_H_
